<!DOCTYPE html>
<html>

<head>
    <title>Three.js Cylinder Grid</title>
    <style>
        body {
            margin: 0;
            background: #ffffff;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>

    <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);

        // Camera
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(10, 12, 14);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.01;
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        document.body.appendChild(renderer.domElement);

        // Controls
        new OrbitControls(camera, renderer.domElement);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.25));

        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(12, 18, 8);
        scene.add(dir);

        const topLight = new THREE.DirectionalLight(0xffffff, 1.1);
        topLight.position.set(0, 20, 0);
        scene.add(topLight);

        // Subtle front fill (smooths gradient)
        const fill = new THREE.DirectionalLight(0xffffff, 0.35);
        fill.position.set(0, 10, 15);
        scene.add(fill);

        // =======================
        // Cylinder Instancing
        // =======================

        const rows = 12;
        const cols = 12;
        const spacing = 1.4;

        const geo = new THREE.CylinderGeometry(
            0.45,
            0.45,
            1.05,   // slightly shorter = stronger top highlight
            48,     // smoother rim
            1,
            false
        );

        const mat = new THREE.MeshPhysicalMaterial({
            color: 0x8fd3e3,        // slightly brighter cyan

            metalness: 0.0,
            roughness: 0.38,        // controls softness

            clearcoat: 1.0,
            clearcoatRoughness: 0.08, // tight glossy highlight

            reflectivity: 0.5,
        });

        const count = rows * cols;
        const mesh = new THREE.InstancedMesh(geo, mat, count);
        scene.add(mesh);

        const dummy = new THREE.Object3D();
        let i = 0;

        // Hex-like offset grid for nicer look
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const offset = (r % 2) * spacing * 0.5;

                dummy.position.set(
                    c * spacing + offset,
                    0,
                    r * spacing * 0.9
                );

                dummy.updateMatrix();
                mesh.setMatrixAt(i++, dummy.matrix);
            }
        }

        // Slight rotation to match angled layout feel
        mesh.rotation.y = -Math.PI / 6;
        mesh.position.set(-7, 0, -6);

        // Ground shadow plane
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 50),
            new THREE.MeshStandardMaterial({ color: 0x1f1f1f })
        );
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -0.61;
        scene.add(plane);

        // Animate
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>

</body>

</html>